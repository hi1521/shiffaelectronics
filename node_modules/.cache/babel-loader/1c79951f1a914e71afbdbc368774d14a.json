{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/home/hishsmtariq/GitProj/spare_part/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/home/hishsmtariq/GitProj/spare_part/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _regeneratorRuntime = require(\"/home/hishsmtariq/GitProj/spare_part/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"/home/hishsmtariq/GitProj/spare_part/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/hishsmtariq/GitProj/spare_part/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar INITIAL_STATE = 1;\nvar FAIL_STATE = 0;\n/**\n * A StateMachine represents a deterministic finite automaton.\n * It can perform matches over a sequence of values, similar to a regular expression.\n */\n\nvar StateMachine = /*#__PURE__*/function () {\n  function StateMachine(dfa) {\n    _classCallCheck(this, StateMachine);\n\n    this.stateTable = dfa.stateTable;\n    this.accepting = dfa.accepting;\n    this.tags = dfa.tags;\n  }\n  /**\n   * Returns an iterable object that yields pattern matches over the input sequence.\n   * Matches are of the form [startIndex, endIndex, tags].\n   */\n\n\n  _createClass(StateMachine, [{\n    key: \"match\",\n    value: function match(str) {\n      var self = this;\n      return {\n        [Symbol.iterator]() {\n          return /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n            var state, startRun, lastAccepting, lastState, p, c;\n            return _regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) {\n                switch (_context.prev = _context.next) {\n                  case 0:\n                    state = INITIAL_STATE;\n                    startRun = null;\n                    lastAccepting = null;\n                    lastState = null;\n                    p = 0;\n\n                  case 5:\n                    if (!(p < str.length)) {\n                      _context.next = 21;\n                      break;\n                    }\n\n                    c = str[p];\n                    lastState = state;\n                    state = self.stateTable[state][c];\n\n                    if (!(state === FAIL_STATE)) {\n                      _context.next = 15;\n                      break;\n                    }\n\n                    if (!(startRun != null && lastAccepting != null && lastAccepting >= startRun)) {\n                      _context.next = 13;\n                      break;\n                    }\n\n                    _context.next = 13;\n                    return [startRun, lastAccepting, self.tags[lastState]];\n\n                  case 13:\n                    // reset the state as if we started over from the initial state\n                    state = self.stateTable[INITIAL_STATE][c];\n                    startRun = null;\n\n                  case 15:\n                    // start a run if not in the failure state\n                    if (state !== FAIL_STATE && startRun == null) {\n                      startRun = p;\n                    } // if accepting, mark the potential match end\n\n\n                    if (self.accepting[state]) {\n                      lastAccepting = p;\n                    } // reset the state to the initial state if we get into the failure state\n\n\n                    if (state === FAIL_STATE) {\n                      state = INITIAL_STATE;\n                    }\n\n                  case 18:\n                    p++;\n                    _context.next = 5;\n                    break;\n\n                  case 21:\n                    if (!(startRun != null && lastAccepting != null && lastAccepting >= startRun)) {\n                      _context.next = 24;\n                      break;\n                    }\n\n                    _context.next = 24;\n                    return [startRun, lastAccepting, self.tags[state]];\n\n                  case 24:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }\n            }, _callee);\n          })();\n        }\n\n      };\n    }\n    /**\n     * For each match over the input sequence, action functions matching\n     * the tag definitions in the input pattern are called with the startIndex,\n     * endIndex, and sub-match sequence.\n     */\n\n  }, {\n    key: \"apply\",\n    value: function apply(str, actions) {\n      var _iterator = _createForOfIteratorHelper(this.match(str)),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 3),\n              start = _step$value[0],\n              end = _step$value[1],\n              tags = _step$value[2];\n\n          var _iterator2 = _createForOfIteratorHelper(tags),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var tag = _step2.value;\n\n              if (typeof actions[tag] === 'function') {\n                actions[tag](start, end, str.slice(start, end + 1));\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }]);\n\n  return StateMachine;\n}();\n\nmodule.exports = StateMachine;","map":{"version":3,"sources":["src/StateMachine.js"],"names":["INITIAL_STATE","FAIL_STATE","constructor","dfa","self","Symbol","state","startRun","lastAccepting","lastState","p","str","c","actions","end"],"mappings":";;;;;;;;;;;;AAAA,IAAMA,aAAa,GAAnB,CAAA;AACA,IAAMC,UAAU,GAAhB,CAAA;;;;;;IAMe,Y;AACbC,wBAAW,GAAXA,EAAiB;AAAA;;SACf,U,GAAkBC,GAAG,CAArB,U;SACA,S,GAAiBA,GAAG,CAApB,S;SACA,I,GAAYA,GAAG,CAAf,I;;;;;;;;;;0BAOG,G,EAAM;UACLC,IAAI,GAAR,I;aACO;SACHC,MAAM,CAAR,Q,IAAqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACfC,oBAAAA,KADe,GACnB,aADmB;AAEfC,oBAAAA,QAFe,GAEnB,IAFmB;AAGfC,oBAAAA,aAHe,GAGnB,IAHmB;AAIfC,oBAAAA,SAJe,GAInB,IAJmB;AAMVC,oBAAAA,CANU,GAMnB,CANmB;;AAAA;AAAA,0BAMHA,CAAC,GAAGC,GAAG,CAAvB,MANmB;AAAA;AAAA;AAAA;;AAObC,oBAAAA,CAPa,GAOTD,GAAG,CAAX,CAAW,CAPM;AASjBF,oBAAAA,SAAS,GAATA,KAAAA;AACAH,oBAAAA,KAAK,GAAGF,IAAI,CAAJA,UAAAA,CAAAA,KAAAA,EAARE,CAAQF,CAARE;;AAViB,0BAYbA,KAAK,KAAT,UAZiB;AAAA;AAAA;AAAA;;AAAA,0BAcXC,QAAQ,IAARA,IAAAA,IAAoBC,aAAa,IAAjCD,IAAAA,IAA6CC,aAAa,IAA9D,QAde;AAAA;AAAA;AAAA;;AAAA;2BAeP,CAAA,QAAA,EAAA,aAAA,EAA0BJ,IAAI,CAAJA,IAAAA,CAAhC,SAAgCA,CAA1B,C;;AAfO;AAYS;AAOxBE,oBAAAA,KAAK,GAAGF,IAAI,CAAJA,UAAAA,CAAAA,aAAAA,EAARE,CAAQF,CAARE;AACAC,oBAAAA,QAAQ,GAARA,IAAAA;;AApBe;AAMkB;wBAkB/BD,KAAK,KAALA,UAAAA,IAAwBC,QAAQ,IAApC,I,EAA8C;AAC5CA,sBAAAA,QAAQ,GAARA,CAAAA;AAnBiC,qBANlB,CAMkB;;;wBAuB/BH,IAAI,CAAJA,SAAAA,CAAJ,KAAIA,C,EAAuB;AACzBI,sBAAAA,aAAa,GAAbA,CAAAA;AAxBiC,qBANlB,CAMkB;;;wBA4B/BF,KAAK,KAAT,U,EAA0B;AACxBA,sBAAAA,KAAK,GAALA,aAAAA;;;AAnCe;AAMaI,oBAAAA,CAAhC,EANmB;AAAA;AAAA;;AAAA;AAAA,0BAwCfH,QAAQ,IAARA,IAAAA,IAAoBC,aAAa,IAAjCD,IAAAA,IAA6CC,aAAa,IAA9D,QAxCmB;AAAA;AAAA;AAAA;;AAAA;2BAyCX,CAAA,QAAA,EAAA,aAAA,EAA0BJ,IAAI,CAAJA,IAAAA,CAAhC,KAAgCA,CAA1B,C;;AAzCW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AADhB,O;;;;;;;;;;0BAqDJ,G,EAAA,O,EAAe;AAAA,iDACa,KAAA,KAAA,CAA/B,GAA+B,CADb;AAAA;;AAAA;AACb,4DAA2C;AAAA;AAAA,cAAvC,KAAuC;AAAA,cAAvC,GAAuC;AAAA,cAAhD,IAAgD;;AAAA,sDAC9C,IAD8C;AAAA;;AAAA;AACzC,mEAAiB;AAAA,kBAAtB,GAAsB;;kBAChB,OAAOS,OAAO,CAAd,GAAc,CAAd,KAAJ,U,EAAwC;AACtCA,gBAAAA,OAAO,CAAPA,GAAO,CAAPA,CAAAA,KAAAA,EAAAA,GAAAA,EAAyBF,GAAG,CAAHA,KAAAA,CAAAA,KAAAA,EAAiBG,GAAG,GAA7CD,CAAyBF,CAAzBE;;;AAH0C;AAAA;AAAA;AAAA;AAAA;;AAD9B;AAAA;AAAA;AAAA;AAAA","sourcesContent":["const INITIAL_STATE = 1;\nconst FAIL_STATE = 0;\n\n/**\n * A StateMachine represents a deterministic finite automaton.\n * It can perform matches over a sequence of values, similar to a regular expression.\n */\nexport default class StateMachine {\n  constructor(dfa) {\n    this.stateTable = dfa.stateTable;\n    this.accepting = dfa.accepting;\n    this.tags = dfa.tags;\n  }\n\n  /**\n   * Returns an iterable object that yields pattern matches over the input sequence.\n   * Matches are of the form [startIndex, endIndex, tags].\n   */\n  match(str) {\n    let self = this;\n    return {\n      *[Symbol.iterator]() {\n        let state = INITIAL_STATE;\n        let startRun = null;\n        let lastAccepting = null;\n        let lastState = null;\n\n        for (let p = 0; p < str.length; p++) {\n          let c = str[p];\n\n          lastState = state;\n          state = self.stateTable[state][c];\n\n          if (state === FAIL_STATE) {\n            // yield the last match if any\n            if (startRun != null && lastAccepting != null && lastAccepting >= startRun) {\n              yield [startRun, lastAccepting, self.tags[lastState]];\n            }\n\n            // reset the state as if we started over from the initial state\n            state = self.stateTable[INITIAL_STATE][c];\n            startRun = null;\n          }\n\n          // start a run if not in the failure state\n          if (state !== FAIL_STATE && startRun == null) {\n            startRun = p;\n          }\n\n          // if accepting, mark the potential match end\n          if (self.accepting[state]) {\n            lastAccepting = p;\n          }\n\n          // reset the state to the initial state if we get into the failure state\n          if (state === FAIL_STATE) {\n            state = INITIAL_STATE;\n          }\n        }\n\n        // yield the last match if any\n        if (startRun != null && lastAccepting != null && lastAccepting >= startRun) {\n          yield [startRun, lastAccepting, self.tags[state]];\n        }\n      }\n    };\n  }\n\n  /**\n   * For each match over the input sequence, action functions matching\n   * the tag definitions in the input pattern are called with the startIndex,\n   * endIndex, and sub-match sequence.\n   */\n  apply(str, actions) {\n    for (let [start, end, tags] of this.match(str)) {\n      for (let tag of tags) {\n        if (typeof actions[tag] === 'function') {\n          actions[tag](start, end, str.slice(start, end + 1));\n        }\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}